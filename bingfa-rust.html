<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-01-02 一 17:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>rust是如何适配并发的？</title>
<meta name="author" content="Zi Liang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="./css/worg.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">rust是如何适配并发的？</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5bbb07b">1. 什么是并发？</a></li>
<li><a href="#org6d9e2ba">2. 处理并行、并发问题的计算机知识</a>
<ul>
<li><a href="#orge89ffbf">2.1. 使用rust创建多线程</a></li>
</ul>
</li>
<li><a href="#org96d4ba1">3. 安全并发的若干解决方案</a>
<ul>
<li><a href="#org01a4a17">3.1. 消息传递：不要通过共享内存来通讯，而是通过通讯来共享内存</a></li>
<li><a href="#org5262e76">3.2. 共享状态：</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5bbb07b" class="outline-2">
<h2 id="org5bbb07b"><span class="section-number-2">1.</span> 什么是并发？</h2>
<div class="outline-text-2" id="text-1">
<p>
并发包括两个概念：并发（concurrent）和并行（parallel）。前者主要是指如何让程序的各个模块彼此独立的执行；而后者，主要指如何将多个程序同时执行。在rust中并不会对并发和并行进行特别清楚地区分。
</p>
</div>
</div>


<div id="outline-container-org6d9e2ba" class="outline-2">
<h2 id="org6d9e2ba"><span class="section-number-2">2.</span> 处理并行、并发问题的计算机知识</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orge89ffbf" class="outline-3">
<h3 id="orge89ffbf"><span class="section-number-3">2.1.</span> 使用rust创建多线程</h3>
<div class="outline-text-3" id="text-2-1">
<p>
我们知道，一个正在执行的计算机程序一般就是一个进程，这个进程里可以包括很多个线程。
所以，我们可以在主线程里创建别的线程，也就是下面所示：
</p>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #49bdb0;">use</span> <span style="color: #ef6787;">std</span>::thread;
<span style="color: #49bdb0;">use</span> <span style="color: #ef6787;">std</span>::<span style="color: #ef6787;">time</span>::<span style="color: #eed891;">Duration</span>;

<span style="color: #49bdb0;">fn</span> <span style="color: #7ED7E6;">main</span><span style="color: #4d9391;">()</span> <span style="color: #4d9391;">{</span>
    <span style="color: #49bdb0;">let</span> <span style="color: #ef6787;">handle</span> = <span style="color: #ef6787;">thread</span>::spawn<span style="color: #47ba99;">(</span>|| <span style="color: #9d81ba;">{</span>
        <span style="color: #49bdb0;">for</span> <span style="color: #ef6787;">i</span> <span style="color: #49bdb0;">in</span> 1..10 {
            <span style="color: #53E6B5;">println!</span><span style="color: #35BF88;">(</span><span style="color: #cea2ca;">"hi number </span><span style="color: #cea2ca; font-style: italic;">{}</span><span style="color: #cea2ca;"> from the spawned thread!"</span>, i<span style="color: #35BF88;">)</span>;
            <span style="color: #ef6787;">thread</span>::sleep<span style="color: #35BF88;">(</span><span style="color: #eed891;">Duration</span>::from_millis<span style="color: #eed891;">(</span>1<span style="color: #eed891;">)</span><span style="color: #35BF88;">)</span>;
        }
    <span style="color: #9d81ba;">}</span><span style="color: #47ba99;">)</span>;

    handle.join<span style="color: #47ba99;">()</span>.unwrap<span style="color: #47ba99;">()</span>;

    <span style="color: #49bdb0;">for</span> <span style="color: #ef6787;">i</span> <span style="color: #49bdb0;">in</span> 1..5 <span style="color: #47ba99;">{</span>
        <span style="color: #53E6B5;">println!</span><span style="color: #9d81ba;">(</span><span style="color: #cea2ca;">"hi number </span><span style="color: #cea2ca; font-style: italic;">{}</span><span style="color: #cea2ca;"> from the main thread!"</span>, i<span style="color: #9d81ba;">)</span>;
        <span style="color: #ef6787;">thread</span>::sleep<span style="color: #9d81ba;">(</span><span style="color: #eed891;">Duration</span>::from_millis(1)<span style="color: #9d81ba;">)</span>;
    <span style="color: #47ba99;">}</span>
<span style="color: #4d9391;">}</span>
</pre>
</div>
<p>
可以看出，thread::spawn就是用来创建新的线程的，而thead::sleep用来对这个定期做一个暂停，
而除此之外还有一行，handle.join(),这一行用来做线程阻断（blocking），也就是要求handle所对应的线程，
在这一行必须运行完成，如果不运行完成，程序就会在这里等待。
</p>

<p>
以上示例主要适用于新线程不需要和主线程做数据交换的情况。下面我们先来看一个最简单的例子，
用以介绍新线程如何借用主线程的数据：
</p>

<div class="org-src-container">
<pre class="src src-rust">   <span style="color: #49bdb0;">use</span> <span style="color: #ef6787;">std</span>::thread;
<span style="color: #49bdb0;">fn</span> <span style="color: #7ED7E6;">main</span><span style="color: #4d9391;">()</span> <span style="color: #4d9391;">{</span>
    <span style="color: #49bdb0;">let</span> <span style="color: #ef6787;">v</span> = <span style="color: #9587DD;">vec!</span><span style="color: #47ba99;">[</span>1, 2, 3<span style="color: #47ba99;">]</span>;

    <span style="color: #49bdb0;">let</span> <span style="color: #ef6787;">handle</span> = <span style="color: #ef6787;">thread</span>::spawn<span style="color: #47ba99;">(</span><span style="color: #49bdb0;">move</span> || <span style="color: #9d81ba;">{</span>
        <span style="color: #53E6B5;">println!</span>(<span style="color: #cea2ca;">"Here's a vector: </span><span style="color: #cea2ca; font-style: italic;">{:?}</span><span style="color: #cea2ca;">"</span>, v);
    <span style="color: #9d81ba;">}</span><span style="color: #47ba99;">)</span>;

    handle.join<span style="color: #47ba99;">()</span>.unwrap<span style="color: #47ba99;">()</span>;
<span style="color: #4d9391;">}</span>
</pre>
</div>
<p>
从这个示例中可以看出，我们可以通过move来获取v的ownership，而非通过引用。因为我们将v的所有权移到了新线程里，原始的main函数将不再拥有处理新线程的作用。这样可以规避什么风险呢？很简单：如果我们在新线程里删掉了v，那么主线程里使用v就会访问一片不存在的内存区域，从而可能引发问题。那我们再来看一看为什么我们不能把v的引用传入到新线程里。这其实涉及到悬垂引用的问题。如果我们把v的引用传入到新线程里，当我们的v在老线程里被处理掉了，新线程必然会出现通过引用访问一片不存在的内存区域的情况。
</p>

<p>
以上两种情况，总结一下就是： <b>由于线程之间执行时间上的弱相关性，如果没有ownership或者强限制的引用，
程序很容易会出现错误。rust尝试在编译时解决以上问题，因此会进行非常严格的检查</b> 。
</p>
</div>
</div>
</div>


<div id="outline-container-org96d4ba1" class="outline-2">
<h2 id="org96d4ba1"><span class="section-number-2">3.</span> 安全并发的若干解决方案</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org01a4a17" class="outline-3">
<h3 id="org01a4a17"><span class="section-number-3">3.1.</span> 消息传递：不要通过共享内存来通讯，而是通过通讯来共享内存</h3>
</div>



<div id="outline-container-org5262e76" class="outline-3">
<h3 id="org5262e76"><span class="section-number-3">3.2.</span> 共享状态：</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: Sat Nov 20 09:19:26 2021</p>
<p class="author">Author: Zi Liang</p>
<p class="date">Created: 2023-01-02 一 17:32</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
