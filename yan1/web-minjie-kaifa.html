<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-01-05 四 16:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>web前端作业——基于React组件化思路开发的山寨版创新港图书馆大数据可视化平台</title>
<meta name="author" content="梁子，软件学院，S0083，3120305385" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">web前端作业——基于React组件化思路开发的山寨版创新港图书馆大数据可视化平台</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2d0754a">1. 场景及功能介绍</a></li>
<li><a href="#orgd0091ef">2. 界面功能实现</a>
<ul>
<li><a href="#org0d3c4f2">2.1. 总体架构</a></li>
<li><a href="#org18d3543">2.2. 各组块实现</a></li>
</ul>
</li>
<li><a href="#org4085f24">3. 安装与运行</a>
<ul>
<li><a href="#org83eda2d">3.1. 安装</a></li>
<li><a href="#orgb7ea2b3">3.2. 运行</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org2d0754a" class="outline-2">
<h2 id="org2d0754a"><span class="section-number-2">1.</span> 场景及功能介绍</h2>
<div class="outline-text-2" id="text-1">
<p>
本作业拟实现的功能是：一个被目前广泛使用的可视化界面。观察到创新港的图书馆中便有屏幕投放这种前端界面，因此打算仿照之实现一个山寨版本。整体结果图示如下图所示：
</p>


<div id="org05fae30" class="figure">
<p><img src="file:///home/liangzi/图片/interface.png" alt="interface.png" />
</p>
</div>

<p>
从图中可以看出，该页面所实现的功能主要包括以下几个方面：
</p>
<ol class="org-ol">
<li>图书馆进出情况分析；</li>
<li>图书借阅情况分析；</li>
<li>各类基础信息统计；</li>
<li>图书借阅类别分布的统计；</li>
<li>借阅者年级分布的统计；</li>
<li>还书机使用频率曲线；</li>
<li>实时时间显示</li>
<li>没有太大含义的中国地图；</li>
</ol>

<p>
关于实现过程请见下一章。
</p>
</div>
</div>
<div id="outline-container-orgd0091ef" class="outline-2">
<h2 id="orgd0091ef"><span class="section-number-2">2.</span> 界面功能实现</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org0d3c4f2" class="outline-3">
<h3 id="org0d3c4f2"><span class="section-number-3">2.1.</span> 总体架构</h3>
<div class="outline-text-3" id="text-2-1">
<p>
本作业所描述平台整体上包含了两部分：前端实现和后端实现。当然，由于后端实现较为简单（即基于简单数据库的对数据的整合和处理），因此本章重点介绍前端部分。整体上而言，本文使用阿里巴巴的前端框架dva进行套装，整体上可分为三大模块：
</p>

<ol class="org-ol">
<li>界面。基于react编写相关组件，用以展示每一个模块；</li>
<li>后端数据。使用json对象模拟后端数据，将所有后端数据存放在固定的文件夹中；</li>
<li>操作逻辑和前端数据。基于dva框架进行存储；</li>
<li>风格样式。使用styled-components进行组件化的css样式使用；</li>
<li>可视化，基于百度的echarts进行可视化。</li>
</ol>

<p>
下图展示了整体上的模型结构实现。下面介绍各个组块的实现原则。
<img src="./images/react.png" alt="react.png" />
</p>
</div>
</div>

<div id="outline-container-org18d3543" class="outline-3">
<h3 id="org18d3543"><span class="section-number-3">2.2.</span> 各组块实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
各个组块的实现均基于react进行，主要包括以下8个原子级别的组块：
</p>

<ol class="org-ol">
<li>时间组块；</li>
<li>标题组块；</li>
<li>地图组块；</li>
<li>图书馆重要统计值数值展示组块；</li>
<li>图书馆进出人数展示组块；</li>
<li>图书借阅榜组块；</li>
<li>图书借阅类别分析组块；</li>
<li>借阅者年级分布展示组块；</li>
<li>还书机使用功能分布组块；</li>
<li>还书机使用频率组块；</li>
</ol>

<p>
基于这八个原子组块，主要将页面划分为三个部分：
</p>
<ol class="org-ol">
<li>顶部，包含标题和当前时间；</li>
<li>左部，包含图书馆进出人数展示、图书借阅榜两大部分；</li>
<li>中部，包含地图和重要统计数值展示；</li>
<li>右部，包含图书馆的一些部分分析结果，及还书机的使用情况；</li>
</ol>

<p>
之后，这三个部分将组成整体的页面。
</p>

<p>
前面已提及，为了更好地展示解耦前端的各个部分，上述各个组块的风格样式以及其交互逻辑均是分离开的，而后使用dva中的connect方法将模型和页面进行拼接。下面以左侧组件试图为例进行介绍。
如前面所述，左侧主要包括图书馆进出人数展示的折线图以及滚动的图书借阅榜，基于此二者的react组件类中的render函数被定义为：
</p>

<div class="org-src-container">
<pre class="src src-js"> render() {
    const { userSitua, trafficSitua, accessFrequency, peakFlow } = this.props;
    return (
      // 风格
      &lt;LeftPage&gt;
	{/* 顶部图表 */}
	&lt;LeftTopBox&gt;
	  &lt;BorderBox12 className='left-top-borderBox12'&gt;
	    &lt;div className='left-top'&gt;
	      &lt;ModuleTitle&gt;
		&lt;i className='iconfont'&gt;&amp;#xe78f;&lt;/i&gt;
		&lt;span&gt;今日图书馆进出情况&lt;/span&gt;
	      &lt;/ModuleTitle&gt;

	      &lt;div className='title-dis'&gt;
		&lt;span&gt;
		  当前参观人数(小时):
		  &lt;span className='title-dis-keyword'&gt;{accessFrequency}人&lt;/span&gt;
		&lt;/span&gt;

		&lt;span&gt;
		  今日总人数:
		  &lt;span className='title-dis-keyword'&gt;{peakFlow}人&lt;/span&gt;
		&lt;/span&gt;
	      &lt;/div&gt;
	      {/* 图表 */}
	      &lt;TrafficSituation trafficSitua={trafficSitua}&gt;&lt;/TrafficSituation&gt;
	    &lt;/div&gt;
	  &lt;/BorderBox12&gt;
	&lt;/LeftTopBox&gt;

	{/* 底部图表 */}
	&lt;LeftBottomBox&gt;
	  &lt;BorderBox13 className='left-bottom-borderBox13'&gt;
	    &lt;div className='left-bottom'&gt;
	      &lt;ModuleTitle&gt;
		&lt;i className='iconfont'&gt;&amp;#xe88e;&lt;/i&gt;
		&lt;span&gt;本周图书借阅榜&lt;/span&gt;
	      &lt;/ModuleTitle&gt;
	      {/* 图表 */}
	      &lt;UserSituation userSitua={userSitua}&gt;&lt;/UserSituation&gt;
	    &lt;/div&gt;
	  &lt;/BorderBox13&gt;
	&lt;/LeftBottomBox&gt;
      &lt;/LeftPage&gt;
    );
  }
}
</pre>
</div>

<p>
从中可以看出，所有的组件均被包括在&lt;LeftPage&gt;之内，在之中，划分得到了底部顶部两个box，而核心的图标区域是两个react组件，TrafficSituation 和 UserSituation。下面先对这几个组件进行简单介绍。
</p>

<p>
首先，LeftPage以及两个box均是针对于css样式风格而撰写的组件，借用了styled-components的写法，如LeftTopBox就包含了如下的样式设定：
</p>

<div class="org-src-container">
<pre class="src src-js">export const LeftTopBox = styled.div`
  position: relative;
  height: 4.375rem;
  width: 100%;
  .left-top-borderBox12 {
    width: inherit;
    height: inherit;
    padding: 0.1875rem;
    .left-top {
      width: 100%;
      height: 100%;
      border-radius: 10px;
      background-color: rgba(19, 25, 47, 0.6);
      .title-dis {
	margin-top: 0.1875rem;
	display: flex;
	justify-content: space-around;
	align-items: center;
	font-size: 0.2rem;
	color: #c0c9d2;
	&amp;-keyword {
	  padding-left: 0.125rem;
	  color: #47dae8;
	}
      }
    }
  }
`;
</pre>
</div>

<p>
而两个Situation，均是react化的echarts组件，该组件一方面需要满足可视化库echarts的一些设定，另一方面又需要满足react的封装风格，以出口人流量为例，可以撰写如下:
</p>


<div class="org-src-container">
<pre class="src src-js">class TrafficSituation extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      renderer: 'canvas',
    };
  }

  render() {
    const { renderer } = this.state;
    const { trafficSitua } = this.props;
    return (
      &lt;div
	style={{
	  width: '5.375rem',
	  height: '3.125rem',
	}}&gt;
	{trafficSitua ? (
	  &lt;Chart renderer={renderer} option={trafficOptions(trafficSitua)} /&gt;
	) : (
	  ''
	)}
      &lt;/div&gt;
    );
  } //endrender
}

export default TrafficSituation;

</pre>
</div>

<p>
其中，相关数据信息是从上游，也就是leftpage组件流到该组件之内的。关于该数据如何流入到LeftPage，后续在介绍数据逻辑时进行介绍。
可以发现，该代码的核心步骤在于使用Chart组件进行数据和选项的配置，关于基础的Chart组件如何撰写，echarts提供了示例代码，如下：
</p>

<div class="org-src-container">
<pre class="src src-js">export default class Chart extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      width: '100%',
      height: '100%',
    };
    this.chart = null;
  }
  // 异步函数
  async componentDidMount() {
    // 初始化图表
    await this.initChart(this.el);
    // 将传入的配置(包含数据)注入
    this.setOption(this.props.option);
    // 监听屏幕缩放，重新绘制 echart 图表
    window.addEventListener('resize', debounce(this.resize, 100));
  }

  componentDidUpdate() {
    // 每次更新组件都重置
    this.setOption(this.props.option);
  }

  componentWillUnmount() {
    // 组件卸载前卸载图表
    this.dispose();
  }

  render() {
    const { width, height } = this.state;

    return (
      &lt;div
	className='default-chart'
	ref={el =&gt; (this.el = el)}
	style={{ width, height }}
      /&gt;
    );
  }


  initChart = el =&gt; {
    // renderer 用于配置渲染方式 可以是 svg 或者 canvas
    const renderer = this.props.renderer || 'canvas';

    return new Promise(resolve =&gt; {
      setTimeout(() =&gt; {
	this.chart = echarts.init(el, null, {
	  renderer,
	  width: 'auto',
	  height: 'auto',
	});
	resolve();
      }, 0);
    });
  };

  setOption = option =&gt; {
    if (!this.chart) {
      return;
    }

    const notMerge = this.props.notMerge;
    const lazyUpdate = this.props.lazyUpdate;

    this.chart.setOption(option, notMerge, lazyUpdate);
  };
  dispose = () =&gt; {
    if (!this.chart) {
      return;
    }

    this.chart.dispose();
    this.chart = null;
  };
  resize = () =&gt; {
    this.chart &amp;&amp; this.chart.resize();
  };
  getInstance = () =&gt; {
    return this.chart;
  };
}
</pre>
</div>

<p>
其中，purecomponent是一种较为特殊的component，该类仅仅当上游props发生改变或自身的state发生改变时才对自身进行重新渲染。
</p>

<p>
当对出口流量的组件形式了解后，另一个问题就是如何配置echarts对象，此处直接针对echarts官方提供的API参数进行修改即可。具体为：
</p>

<div class="org-src-container">
<pre class="src src-js">export const trafficOptions = (params) =&gt; ({
  title: {
    show: false,
  },
  legend: {
    show: true,
    top: '5%',
    textStyle: {
      color: '#c0c9d2',
    },
  },
  tooltip: {
    trigger: 'axis',
    axisPointer: {
      lineStyle: {
	color: {
	  type: 'linear',
	  x: 0,
	  y: 0,
	  x2: 0,
	  y2: 1,
	  colorStops: [
	    {
	      offset: 0,
	      color: 'rgba(0, 255, 233,0)',
	    },
	    {
	      offset: 0.5,
	      color: 'rgba(255, 255, 255,1)',
	    },
	    {
	      offset: 1,
	      color: 'rgba(0, 255, 233,0)',
	    },
	  ],
	  global: false,
	},
      },
    },
  },
  grid: {
    top: '15%',
    left: '10%',
    right: '5%',
    bottom: '10%',
  },
  xAxis: {
    type: 'category',
    axisLine: {
      show: true,
    },
    splitArea: {
      color: '#f00',
      lineStyle: {
	color: '#f00',
      },
    },
    axisLabel: {
      color: '#BCDCF0',
    },
    splitLine: {
      show: false,
    },
    boundaryGap: false,
    data: params.timeList,
  },

  yAxis: {
    type: 'value',
    min: 0,
    splitLine: {
      show: true,
      lineStyle: {
	color: 'rgba(255,255,255,0.1)',
      },
    },
    axisLine: {
      show: true,
    },
    axisLabel: {
      show: true,
      margin: 10,
      textStyle: {
	color: '#d1e6eb',
      },
    },
    axisTick: {
      show: false,
    },
  },
  series: [
    {
      name: '进入人数',
      type: 'line',
      smooth: true, //是否平滑
      lineStyle: {
	normal: {
	  color: '#00b3f4',
	  shadowColor: 'rgba(0, 0, 0, .3)',
	  shadowBlur: 0,
	  shadowOffsetY: 5,
	  shadowOffsetX: 5,
	},
      },
      label: {
	show: false,
	position: 'top',
	textStyle: {
	  color: '#00b3f4',
	},
      },
      // 去除点标记
      symbolSize: 0,
      // 鼠标放上去还是要有颜色的
      itemStyle: {
	color: '#00b3f4',
      },
      // 设置渐变色
      areaStyle: {
	normal: {
	  color: new echarts.graphic.LinearGradient(
	    0,
	    0,
	    0,
	    1,
	    [
	      {
		offset: 0,
		color: 'rgba(0,179,244,0.3)',
	      },
	      {
		offset: 1,
		color: 'rgba(0,179,244,0)',
	      },
	    ],
	    false
	  ),
	  shadowColor: 'rgba(0,179,244, 0.9)',
	  shadowBlur: 20,
	},
      },
      data: params.outData,
    },
    {
      name: '走出人数',
      type: 'line',
      smooth: true, //是否平滑
      // 阴影
      lineStyle: {
	normal: {
	  color: '#00ca95',
	  shadowColor: 'rgba(0, 0, 0, .3)',
	  shadowBlur: 0,
	  shadowOffsetY: 5,
	  shadowOffsetX: 5,
	},
      },
      label: {
	show: false,
	position: 'top',
	textStyle: {
	  color: '#00ca95',
	},
      },
      // 去除点标记
      symbolSize: 0,
      itemStyle: {
	color: '#00ca95',
      },
      // 设置渐变色
      areaStyle: {
	normal: {
	  color: new echarts.graphic.LinearGradient(
	    0,
	    0,
	    0,
	    1,
	    [
	      {
		offset: 0,
		color: 'rgba(0,202,149,0.3)',
	      },
	      {
		offset: 1,
		color: 'rgba(0,202,149,0)',
	      },
	    ],
	    false
	  ),
	  shadowColor: 'rgba(0,202,149, 0.9)',
	  shadowBlur: 20,
	},
      },
      data: params.inData,
    },
  ],
});
</pre>
</div>

<p>
通过这种方式，即可完成对一个echarts折线图的全部处理了。
</p>

<p>
另外的问题是，数据是如何从后端流入到当前组件的。依照react的思路，一般而言，数据的变动包含两个原则：
</p>
<ol class="org-ol">
<li>对于一个组件节点，如果该组件节点触发了状态变动，则依照变动情况进行处理：若只影响以当前节点为根节点的子树，则在当前节点改变，否则需要找到最小公共子树，在其之上改变状态，或在根节点改变状态。老师上课所写的todo APP即是此种逻辑；</li>
<li>对于一个组件节点，其所需要的数据，只能是自身状态提供的，或是父节点传递过来的；</li>
</ol>

<p>
此处自然也是基于这两个原则进行的，不过稍有不同。这里的不同主要体现在数据传送的方法上，同样以leftpage为例，数据从leftpage传送到各个子组件是遵循上述原则的。不过，由于直接同外界交互，leftpage获取数据是依照dva框架的形式进行的，该交互主要包括三个部分：数据来源，数据处理、数据导出展示。
</p>

<p>
比如，对于leftpage，需要获得两个对象，分别是人流量信息和图书排行榜信息，这些信息从后端获取，因此第一个操作是一个get操作。如果获取失败，则进入异常处理环节，否则便需要将获取得到的数据传入到leftpage组件之后，令之使用pros获得。
对于上述整个流程，在从后端获取数据的环节，主要代码是：
</p>

<div class="org-src-container">
<pre class="src src-js">export default function request(url, options) {
  return fetch(url, options)
    .then(checkStatus)
    .then(parseJSON)
    .then(data =&gt; ({ data }))
    .catch(err =&gt; ({ err }));
}

export const getLeftPageData = async () =&gt; {
  return request('/api/leftPageData').then(response =&gt; {
    return response.data;
  });
};

</pre>
</div>

<p>
对于所获得的数据，dva会设置如下的model：
</p>

<div class="org-src-container">
<pre class="src src-js">export default {
  // 命名空间 (必填)
  namespace: 'leftPage',

  // 数据
  state: {},

  // 路由监听
  subscriptions: {
    setup({ dispatch, history }) {
      return history.listen((location, action) =&gt; {
	// 参数可以直接简写成{pathname}
	if (location.pathname === '/') { //当进入当前页面就执行获取数据这一action
	  dispatch({ type: 'getLeftPageData' });
	}
      });
    },
  },

  // 异步请求    action处理器，用以对异步动作进行处理
  effects: {
    *getLeftPageData({ payload }, { call, put }) {
      const data = yield call(getLeftPageData); 
      if (data) {
	yield put({
	  type: 'setData',
	  payload: data,
	});
      } else {
	console.log(`获取左侧数据数据失败`);
      }
    },
  },

  // 同步操作
  reducers: {
    setData(state, action) {
      return { ...state, ...action.payload };
    },
  },
};

</pre>
</div>

<p>
可以看出，该过程主要包含了如下几个部分：
</p>
<ol class="org-ol">
<li>路由监听，主要是设置何时进行dispatch，也就是什么时候进行数据获取；</li>
<li>effects，负责对异步动作进行处理，此处即是对获取左侧数据进行这一动作进行执行。同时，该过程使用了标准的yield-put结构，该结构会在需要时尝试运行一个动作，如果成功，则派发后续动作（put），以调用同步操作setData；</li>
<li>reducers，等价于原始react中的setState。</li>
</ol>

<p>
基于以上的介绍，整体的前端运行方式就较为清晰了。后续是如何对之进行安装和使用。
</p>
</div>
</div>
</div>


<div id="outline-container-org4085f24" class="outline-2">
<h2 id="org4085f24"><span class="section-number-2">3.</span> 安装与运行</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org83eda2d" class="outline-3">
<h3 id="org83eda2d"><span class="section-number-3">3.1.</span> 安装</h3>
<div class="outline-text-3" id="text-3-1">
<p>
基于npm进行依赖安装
</p>
<div class="org-src-container">
<pre class="src src-sh">npm install
</pre>
</div>
<p>
主要包括以下依赖：
</p>
<div class="org-src-container">
<pre class="src src-js">"dependencies": {
   "@jiaminghi/data-view-react": "^1.2.4",
   "dva": "^2.4.1",
   "echarts": "^4.9.0",
   "react": "^16.2.0",
   "react-dom": "^16.2.0",
   "sass-loader": "8.0.2",
   "styled-components": "^5.2.0"
 },
</pre>
</div>
<p>
其中，sass的安装可能会出现报错，可以先进行额外的处理。
</p>
</div>
</div>
<div id="outline-container-orgb7ea2b3" class="outline-3">
<h3 id="orgb7ea2b3"><span class="section-number-3">3.2.</span> 运行</h3>
<div class="outline-text-3" id="text-3-2">
<p>
运行下列命令，即可在浏览器打开相关页面，F11进入全屏中即可使用。
</p>
<div class="org-src-container">
<pre class="src src-sh">npm start 
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: Sun Jul 11 17:08:49 2021</p>
<p class="author">Author: 梁子，软件学院，S0083，3120305385</p>
<p class="date">Created: 2023-01-05 四 16:37</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
